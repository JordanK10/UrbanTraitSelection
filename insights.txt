### Core Insight: A Tale of Two Models

The central reason for the sanity check failures and confusion is that `derivation.txt`, `aggregatePriceV4.py`, and `aggregatePriceV5.py` are implicitly dealing with two different, mathematically distinct models for hierarchical decomposition.

---

### Model 1: The "Pure Recursive Model" (from `derivation.txt`)

This model is a purely bottom-up construction.

1.  **Base Trait Calculation**: The trait of interest (`z`), which is average log-income `E[ln(y)]`, is calculated *only* at the most granular level (the block group, `bg`) directly from its income distribution data.
    - `z_bg = E[ln(y_bg)]`

2.  **Parent Trait Definition**: The trait of any higher-level "parent" unit (tract, community, etc.) is *defined as* the population-weighted average of its immediate children's traits. It is not calculated from its own data distribution.
    - `z_tract ≡ E_bg[z_bg]` (The tract's trait *is* the average of its block groups' traits).
    - `z_community ≡ E_tract[z_tract]` (The community's trait *is* the average of its tracts' traits).
    - ...and so on.

3.  **Implication**: In this model, the parent's growth is `Δz_parent = Δ(E_child[z_child])`. The Price Equation is used to decompose this growth into selection and transmission components that are also defined relative to the children's traits. This is the model you laid out in the derivation.

---

### Model 2: The "Pragmatic Parallel Model" (implemented in `aggregatePriceV4.py`)

This model treats every spatial unit, regardless of its level, as an independent entity with its own measurable trait.

1.  **Universal Trait Calculation**: The trait `z_k = ln(E[y_k])` is calculated for *every* unit `k` at *every* level, always from its own fully aggregated income distribution. `procPrice.py` is responsible for this pre-calculation.
    - `z_bg = ln(E[y_bg])`
    - `z_tract = ln(E[y_tract])`
    - `z_community = ln(E[y_community])`

2.  **Price Equation as a Bridge**: The Price Equation is not used to define the parent's trait, but rather to serve as a mathematical bridge that connects the independently-measured traits across scales. It demonstrates how `Δz_parent` can be decomposed into terms involving `z_child` and `w_child`.

3.  **Sanity Check in V4**: The sanity check in V4 works because it is consistent with this model. It compares:
    - **LHS**: The empirically measured `Δz_parent` (from `procPrice.py`).
    - **RHS**: The full decomposition calculated from the children's empirical traits (`Δz_child`).
    - Since the Price Equation is a mathematical identity, and the trait `z` is defined consistently (if not recursively), this check correctly passes.

---

### The Conflict: The "Mixed Model" (in `aggregatePriceV5.py`)

This is where the failure occurs. `aggregatePriceV5.py` was refactored in a way that accidentally mixed the two models, leading to a mathematically invalid comparison.

1.  **RHS Calculation**: The Right-Hand Side of the sanity check (the decomposition) is calculated using the "Pragmatic Parallel Model" (Model 2), just like in V4.

2.  **LHS Calculation**: The Left-Hand Side, however, is calculated using the "Pure Recursive Model" (Model 1). The parent's growth is calculated on-the-fly by taking the change in the average of its children's traits: `Δ(E_child[z_child])`.

3.  **Why the Check Fails (Jensen's Inequality)**: The check `LHS == RHS` fails because the two sides are measuring fundamentally different quantities. Due to the non-linear nature of the logarithm function, the order of averaging and applying the function matters.
    - **LHS (V5)**: `Δ(E[z_child]) = Δ(E[ln(E[y_child])])`
    - **LHS (V4)**: `Δ(z_parent) = Δ(ln(E[y_parent])) = Δ(ln(E[E[y_child]]))`

    Because `E[ln(X)] ≠ ln(E[X])`, the two LHS values are not equal, causing the otherwise correct decomposition on the RHS to fail the sanity check in V5.

### Conclusion

Your intuition was correct all along. The code in V4 is internally consistent and passes its own checks, but it does **not** implement the purely recursive model you designed in `derivation.txt`. The code in V5 fails not because of a bug in the decomposition logic itself, but because its improved sanity check correctly identifies this fundamental discrepancy between the parent's growth (`LHS`) it calculates and the decomposition (`RHS`) it's testing against. 